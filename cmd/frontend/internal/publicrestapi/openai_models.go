package publicrestapi

// This file is generated by Cody with the following prompt:
//  @openapi.yaml write Go structs for the /chat/completions endpoints. You need to respect `oneOf` types. For example,
//
// - For the `stop` property, when it's a string, decode it as a string array with a single element
// - For the `content` property, when it's a string, decode it as an array with a single element with the message { text: STRING }
//
// This spec is intentionally a subset of the OpenAI API. Don't hallucinate fields that are not declared in openapi.yaml (for example, there are no function/tool features)

import "encoding/json"

type CreateChatCompletionRequest struct {
	Messages         []ChatCompletionRequestMessage `json:"messages"`
	Model            string                         `json:"model"`
	FrequencyPenalty *float64                       `json:"frequency_penalty,omitempty"`
	LogitBias        map[string]int                 `json:"logit_bias,omitempty"`
	Logprobs         *bool                          `json:"logprobs,omitempty"`
	TopLogprobs      *int                           `json:"top_logprobs,omitempty"`
	MaxTokens        *int                           `json:"max_tokens,omitempty"`
	N                *int                           `json:"n,omitempty"`
	PresencePenalty  *float64                       `json:"presence_penalty,omitempty"`
	ResponseFormat   *ResponseFormat                `json:"response_format,omitempty"`
	Seed             *int64                         `json:"seed,omitempty"`
	ServiceTier      *string                        `json:"service_tier,omitempty"`
	Stop             []string                       `json:"stop,omitempty"`
	Stream           *bool                          `json:"stream,omitempty"`
	StreamOptions    *ChatCompletionStreamOptions   `json:"stream_options,omitempty"`
	Temperature      *float64                       `json:"temperature,omitempty"`
	TopP             *float64                       `json:"top_p,omitempty"`
	User             *string                        `json:"user,omitempty"`
}

type ChatCompletionRequestMessage struct {
	Content interface{} `json:"content"`
	Role    string      `json:"role"`
	Name    *string     `json:"name,omitempty"`
}

type ResponseFormat struct {
	Type string `json:"type"`
}

type ChatCompletionStreamOptions struct {
	IncludeUsage *bool `json:"include_usage,omitempty"`
}

type CreateChatCompletionResponse struct {
	ID                string                 `json:"id"`
	Choices           []ChatCompletionChoice `json:"choices"`
	Created           int64                  `json:"created"`
	Model             string                 `json:"model"`
	ServiceTier       *string                `json:"service_tier,omitempty"`
	SystemFingerprint string                 `json:"system_fingerprint"`
	Object            string                 `json:"object"`
	Usage             CompletionUsage        `json:"usage"`
}

type ChatCompletionChoice struct {
	FinishReason string                        `json:"finish_reason"`
	Index        int                           `json:"index"`
	Message      ChatCompletionResponseMessage `json:"message"`
	Logprobs     *ChatCompletionLogprobs       `json:"logprobs,omitempty"`
}

type ChatCompletionResponseMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

type ChatCompletionLogprobs struct {
	Content []ChatCompletionTokenLogprob `json:"content"`
}

type ChatCompletionTokenLogprob struct {
	Token       string                  `json:"token"`
	Logprob     float64                 `json:"logprob"`
	Bytes       []int                   `json:"bytes"`
	TopLogprobs []ChatCompletionLogprob `json:"top_logprobs"`
}

type ChatCompletionLogprob struct {
	Token   string  `json:"token"`
	Logprob float64 `json:"logprob"`
	Bytes   []int   `json:"bytes"`
}

type CompletionUsage struct {
	CompletionTokens int `json:"completion_tokens"`
	PromptTokens     int `json:"prompt_tokens"`
	TotalTokens      int `json:"total_tokens"`
}

// Custom UnmarshalJSON for ChatCompletionRequestMessage to handle content
func (m *ChatCompletionRequestMessage) UnmarshalJSON(data []byte) error {
	type Alias ChatCompletionRequestMessage
	aux := &struct {
		Content json.RawMessage `json:"content"`
		*Alias
	}{
		Alias: (*Alias)(m),
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	var contentStr string
	if err := json.Unmarshal(aux.Content, &contentStr); err == nil {
		m.Content = []map[string]string{{"type": "text", "text": contentStr}}
	} else {
		var contentArr []map[string]string
		if err := json.Unmarshal(aux.Content, &contentArr); err != nil {
			return err
		}
		m.Content = contentArr
	}
	return nil
}

// Custom UnmarshalJSON for CreateChatCompletionRequest to handle stop
func (r *CreateChatCompletionRequest) UnmarshalJSON(data []byte) error {
	type Alias CreateChatCompletionRequest
	aux := &struct {
		Stop json.RawMessage `json:"stop"`
		*Alias
	}{
		Alias: (*Alias)(r),
	}
	if err := json.Unmarshal(data, &aux); err != nil {
		return err
	}
	var stopStr string
	if err := json.Unmarshal(aux.Stop, &stopStr); err == nil {
		r.Stop = []string{stopStr}
	} else {
		var stopArr []string
		if err := json.Unmarshal(aux.Stop, &stopArr); err != nil {
			return err
		}
		r.Stop = stopArr
	}
	return nil
}
